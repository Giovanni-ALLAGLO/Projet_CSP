import random as rd
import copy

class Contrainte:
    """Summary : Classe définissant les contraintes d'une CSP.

    Parameters
    ----------
    l_couple : list
        Liste des couples possibles entre deux noeuds, [clé de contraintes(dict)] et [v_destination].
    v_destination: int
        Variable dont la valeur est en deuxieme position dans le couple.
    """
    def __init__(self,v_destination,couples:list):
        self.v_destination = v_destination
        self.l_couple = couples
        pass

class Csp:
    """Summary : Classe definisant un CSP(Constraint Satisfaction Problem).

    Parameters
    ----------
    name : str
        Nommer le CSP.
    nb_var : int
        Nombre de variable.
    nb_valeur : int
        Taille du domaine des varibales.
    densite : int
        Pourcentage de la densité des liaison entre deux variables.
    durete_contrainte : int
        Dureté _pourcentage entre 0 et 1_ sur les contraintes liant deux variables.
    contraintes : dict
        Dictionnaire etablissant les contraintes entre la variable clé et les variables id supérieur.
    domain : dict
        Dictionnaire associant chaque variable et une liste des élements de du domaine.
    """
    def __init__(self, name ="csp", nb_var = None ,nb_valeur= None, durete_contrainte = None , dense = None ):
        self.name = name
        self.nb_valeur = nb_valeur
        self.nb_var = nb_var
        self.durete_contrainte = durete_contrainte
        self.densite = dense
        self.contraintes = dict()
        self.domaines = dict()
        pass


    def ajoutVariable(self, v_id , v_domain:list)->None:
        """Summary : Ajout de la variable v_id au CSP.
                    Initialise la structure de données des contraintes. """
        if v_id not in self.domaines.keys(): # variable existe ?
            self.domaines[v_id] = v_domain
            self.contraintes[v_id] = []


    def ajoutContrainte(self, v_id1, v_id2, liste:list)->None:
        """Summary : Ajout de contrainte sur des variables existantes.

          Arguments
          ---------
          v_id1, v_id2 : type non-defini
            Variables telles que v_id1<v_id2
          liste : list
            Liste des valeurs permises entre v_id1 et v_id2
        """
        if v_id1 in self.domaines.keys() and v_id2 in self.domaines.keys(): #existence des variables ?
            verif = True
            for constr in liste:
                if not (constr[0] in self.domaines[v_id1] and  constr[1] in self.domaines[v_id2]): #valeur de variable valide?
                   #print (f"Incohérence au niveau de {constr}")
                   verif = False
                   break
            if verif:
                self.contraintes[v_id1].append(Contrainte(v_id2,liste))

def gen_csp(name , taille:int, nb_var:int , dur_constr, dense ):
    """Summary : Generation aléatoire de CSP (1 <= variable <= taille) .

       Arguments
       ---------
       name :
        Nom de la Csp
       taille : int
        Taille des domaines
       nb_var : int
         Nombre de variable
       dense : float
        Compris entre 0 et 1, densité de la Csp
       dur_constr : float
        Compris entre 0 et 1, dureté des contraintes entre variables
       """

    modele = Csp( name ,nb_var ,taille , dur_constr , dense)
    for var in range (1,nb_var+1):
        #taille des domaines fixé > ensemble domaine > ajout de variable au csp
        modele.ajoutVariable(var,list(range(taille)))

    #tout les couples (arcs) possibles
    arcs_possibles = [(x,y) for x in range(1,nb_var) for y in range(x+1,nb_var+1)]
    #calcul du nombre de liens(densité)
    nb_arcs  = int(dense*nb_var*(nb_var-1)/2)
    #choix aleatoire de nb_link couples aleatoire deux a deux distincts
    arcs_choisis = rd.sample( arcs_possibles,nb_arcs )

    # dureté > nombre de contraintes sur l'arc courant (couple)
    nb_constraintes = int((taille**2)*(1-dur_constr))
    for couple in arcs_choisis:
        # toute les valeurs couples possibles sur l'arc 'couple'
        valeursCouple_possibles = [(x,y) for x in modele.domaines[couple[0]] for y in modele.domaines[couple[1]]]
        # selection aleatoire de nb_const couples > ajout des contraintes
        valeursCouple_choisies = rd.sample( valeursCouple_possibles,nb_constraintes)
        modele.ajoutContrainte(couple[0],couple[1],valeursCouple_choisies)

    return modele


def affich_csp(csp):
    """Summary : Fonction d'affichage de CSP ."""
    print(f"Cette struture de donnée est une csp \nNom : {csp.name} \nNombre de variables : {csp.nb_var} \nTaille des domaines : {csp.nb_valeur} \nDensité : {csp.densite} \nDureté des contraintes : {csp.durete_contrainte}\n")
    print("Domaines de définition")
    for id in range(1,csp.nb_var+1):
        print(f"Domaine de la variable {id} : {csp.domaines[id]}")
    print("\nEnsemble des contraintes")
    for id in range(1,csp.nb_var+1):
        for c in csp.contraintes[id]:
            print(f"Contrainte binaire C_{id}{c.v_destination} : {c.l_couple}")


def csp_N_reine(N):
    """Summary : Generateur de CSP pour le probleme des N-reines."""
    modele = Csp(f"{N}-reines" , N, N)
    for var in range (1,N+1):
        #taille des domaines fixé > ensemble domaine > ajout de variable au csp
        modele.ajoutVariable(var,list(range(1,N+1)))
    for id1 in range(1,N):
        for id2 in range(id1+1,N+1):
            liste = []
            for val in modele.domaines[id1]:
                for j in modele.domaines[id2]:
                    if j!=val and j!=(val+(id2-id1)) and j!=((val-(id2-id1))):
                        liste.append((val,j))
            modele.ajoutContrainte(id1,id2,liste)
    modele.densite=1
    modele.durete_contrainte= 0.5
    return modele

def consistent_assignment(csp_contraintes,listeAssignment,X):
    """Summary : Verifiant la consistence de x en fonction de valeur des varibles presentes dans liste.

    Arguments
    =========
    csp_contraintes : dict
        Dictionnaires des contraintes du csp.
    listeAssignment : list
        Liste des valeurs coherentes (déjà trouvées) de sorte que variable id=i à la valeur liste[i-1].
    X : int
        Candidat potentiel pour assignation de la variable id= len(liste).

    Return
    ======
    (boolean)
        True si x est une assignation coherente.
        False sinon .
    """
    taille_listeAssignment = len(listeAssignment)
    X_id = taille_listeAssignment+1 # id de la variable de x
    if taille_listeAssignment == 0: #assignation de la première variable id =1
        for constr in csp_contraintes[X_id]:
            for c in constr.l_couple:
                if X == c[0]:
                    return True
        if len(csp_contraintes[X_id])==0: # variable independante?
            return True
        return False
    else:
        for i in range(taille_listeAssignment):
            for constr in csp_contraintes[i+1]:
                if constr.v_destination == X_id and not((listeAssignment[i],X) in constr.l_couple):
                    return False
        return True


def backtracking(csp):
    """Summary : Determine si le csp est Satisfiable ou non.

    Arguments
    =========
    csp : Csp

    Return
    ======
    (tuple)
        La reponse ("UNSAT",None) ou ("SAT",first solution)
    """
    counter =0
    alpha= None
    current_id =1
    domain_list= dict()
    for i in range(1,len(csp.domaines)+1):
        domain_list[i]= (csp.domaines[i])[:]
    liste = []
    print("Search starts...\n")
    while(current_id<=csp.nb_var and current_id>=1):
        counter+=1
        verrou = False
        while not(verrou) and len(domain_list[current_id])!=0:
            alpha = domain_list[current_id].pop()
            verrou = consistent_assignment(csp.contraintes,liste,alpha)
        #print(f"    Current iteration : choix de la variable id={current_id}")
        if not(verrou):
            domain_list[current_id] = (csp.domaines[current_id])[:]
            current_id-=1
            if current_id == 0: # or if len(liste)==0:
                print("\tUnsatisfiable\n")
                return "UNSAT",None
            liste.pop()
            #print(f"\t<--Backtraking : choix de la variable id={current_id}\n")
        else:
            liste.append(alpha)
            #print("\tSolution search: in progress ...")
            current_id+=1
            '''print("\t[", end="  ")
            for i in range(len(liste)):
                print(f"V{i+1}: {liste[i]}",end="   ")
            print("]\n")'''
    print(counter)
    return "SAT",liste


def backtracking_allsolution(csp):
    """Summary :    Determine le nombre de solution .

       Arguments
       ---------
       csp : Csp

       Return
       ------
       (tuple)
            (nombre de solution,liste de solution)
    """
    counter =0
    liste_s = []
    alpha= None
    current_id =1
    domain_list= dict()
    for i in range(1,len(csp.domaines)+1):
        domain_list[i]= (csp.domaines[i])[:]
    liste = []
    print("Search starts...\n")
    while(current_id<=csp.nb_var and current_id>=1):
        counter+=1
        verrou = False
        while not(verrou) and len(domain_list[current_id])!=0:
            alpha = domain_list[current_id].pop()
            verrou = consistent_assignment(csp.contraintes,liste,alpha)
        if not(verrou):
            domain_list[current_id] = (csp.domaines[current_id])[:]
            current_id-=1
            if current_id == 0:
                t=len(liste_s)
                if t==0:
                    #print("tour de boucle : ",counter)
                    return (0,[])
                else:
                    return(t,liste_s)
            liste.pop()
        else:
            liste.append(alpha)
            current_id+=1
            if current_id>csp.nb_var:
                #print("tour de boucle : ",counter)
                liste_s.append(liste[:])
                current_id-=1
                liste.pop()
    return -1 # error

def find_parents(csp):
    """Summary : Fournit les parents de chaque variable selon la structure du graphe.
                Convention -: Les parents ont toujours un id inférieur aux fils.

    Arguments
    =========
    csp : Csp

    Return
    ======
    (dict)
        la liste de parents de chaque variable-clé v .
    """
    parents = dict()
    for id in (csp.contraintes).keys():
        parents[id]=[]
    for id,value in (csp.contraintes).items():
        for constr in value:
            tmp = len(csp.domaines[id])*len(csp.domaines[constr.v_destination])
            if len(constr.l_couple)== tmp:
                break
            else:
                parents[constr.v_destination].append(id)
    for id,value in parents.items():
        if len(value)==0:
            parents[id]=[0]
    return parents

def backjumping(csp,parents):
    '''Summary : Determine si le csp est Satisfiable ou non

       Arguments
       ---------
       csp : Csp
       parents: dict

       Return
       ------
       (tuple)
            ("UNSAT",None) ou ("SAT",first solution)
    '''
    alpha= None
    current_id =1
    domain_list = copy.deepcopy(csp.domaines)
    parents_list = copy.deepcopy(parents)
    liste = []
    print("Search starts...\n")
    while(current_id<=csp.nb_var and current_id>=1):
        verrou = False
        while not(verrou) and len(domain_list[current_id])!=0:
            alpha = domain_list[current_id].pop()
            verrou = consistent_assignment(csp.contraintes,liste,alpha)
        print(f"    Current iteration : choix de la variable id={current_id}")
        if not(verrou):
            current_id, previous_current_id = max(parents_list[current_id]),current_id
            if current_id == 0:
                print("\tUnsatisfiable\n")
                return "UNSAT",None
            i_extract = previous_current_id - current_id
            liste = liste[:-i_extract]
            parents_list[current_id]=list(set(parents_list[current_id]+[i for i in parents_list[previous_current_id] if i!=current_id]))
            for i in range(current_id+1,previous_current_id+1):
                domain_list[i] = (csp.domaines[i])[:]
            print(f"\t<--Backjumping: choix de la variable id={current_id}\n")

        else:
            liste.append(alpha)
            print("\tSolution search: in progress ...")
            current_id+=1
            if current_id<=csp.nb_var:
                parents_list[current_id] = parents[current_id][:]
            print("\t[", end="  ")
            for i in range(len(liste)):
                print(f"V{i+1}: {liste[i]}",end="   ")
            print("]\n")
    return "SAT",liste

def backjumping_allsolution(csp,parents):
    '''Summary : Determine l'ensemble solution

       Arguments
       ---------
       csp : Csp
       parents: dict

       Return
       ------
       (tuple)
            (nombre de solution,liste de solution)
    '''
    counter =0
    liste_s=[]
    current_id =1
    alpha= None
    domain_list = copy.deepcopy(csp.domaines)
    parents_list = copy.deepcopy(parents)
    liste = []
    print("Search starts...\n")
    while(current_id<=csp.nb_var and current_id>=1):
        counter+=1
        verrou = False
        while not(verrou) and len(domain_list[current_id])!=0:
            alpha = domain_list[current_id].pop()
            verrou = consistent_assignment(csp.contraintes,liste,alpha)
        #print(f"    Current iteration : choix de la variable id={current_id}")
        if not(verrou):
            current_id, previous_current_id = max(parents_list[current_id]),current_id
            if current_id == 0:
                t=len(liste_s)
                if t==0:
                    #print("tour de boucle : ",counter)
                    return (0,[])
                else:
                    return(t,liste_s)
            i_extract = previous_current_id - current_id
            liste = liste[:-i_extract]
            parents_list[current_id]=list(set(parents_list[current_id]+[i for i in parents_list[previous_current_id] if i!=current_id]))
            #print(f"\t<--Backjumping: choix de la variable id={current_id}\n")
        else:
            liste.append(alpha)
            #print("\tSolution search: in progress ...")
            current_id+=1
            if current_id<=csp.nb_var:
                domain_list[current_id] = (csp.domaines[current_id])[:]
                parents_list[current_id] = parents[current_id][:]
            if current_id>csp.nb_var:
                #print("tour de boucle : ",counter)
                liste_s.append(liste[:])
                current_id-=1
                liste.pop()
    return -1 # Error

def revise(csp_contraintes,id,x,k):
    """Summary : Verifiant la consistence de x en fonction du fait qu'il soit toujours possible ou non de trouver une solution.
                Cela se traduit par le fait que les domaines revisés soit non vides.

    Arguments
    ---------
    csp_contraintes : dict
        Dictionnaires des contraintes du csp.
    id : int
        variable en cours d'assignation
    x : int
        Candidat potentiel pour assignation de la variable id.
    k : int
        variable dont le domaine sera revisé en fonction des contraintes le liant à id

    Return
    ------
    (list)
        list du domaine revisé de la variable k en propageant les contraintes de la variable id
    """
    tmp_liste = None
    for val in csp_contraintes[id]:
        if val.v_destination == k:
            tmp_liste = [c[1] for c in val.l_couple if c[0]==x]
    return tmp_liste

def fd_checking(csp):
    """Summary : Determine si le csp est Satisfiable ou non.

    Arguments
    =========
    csp : Csp

    Return
    ======
    (tuple)
        La reponse ("UNSAT",None) ou ("SAT",first solution)
    """
    alpha= None
    current_id =1
    domain_list = (csp.nb_var+2)*[None]
    domain_list [1] = copy.deepcopy(csp.domaines)
    liste = []
    print("Search starts...\n")
    while(current_id<=csp.nb_var and current_id>=1):
        verrou = False
        while not(verrou) and len(domain_list[current_id][current_id])!=0:
            alpha = domain_list[current_id][current_id].pop()
            is_emptyDomain = False
            #print(f"    Current iteration : choix de la variable id={current_id}")
            tmp_domain = copy.deepcopy(domain_list[current_id])
            for k in range(current_id+1,csp.nb_var+1):
                revise_list = revise(csp.contraintes,current_id,alpha,k)
                if revise_list!= None: #Aucune contrainte
                    tmp_domain[k]= [ i for i in domain_list[current_id][k] if i in revise(csp.contraintes,current_id,alpha,k)]
                #print(f"Next potential value of V{k} : {tmp_domain[k]}")
                if len(tmp_domain[k])==0:
                    is_emptyDomain = True
                    break
            if not(is_emptyDomain):
                domain_list[current_id+1]=tmp_domain
                verrou = True
            #else:
               #print(f"\tvalue {alpha} for V{current_id} failed. Another value or backtrack\n")

        if not(verrou):
            current_id-=1
            if current_id == 0:
                #print("\tUnsatisfiable\n")
                return "UNSAT",None
            liste.pop()
            #print(f"\t<--Backtraking : choix de la variable id={current_id}\n")
        else:
            liste.append(alpha)
            #print("\tSolution search: in progress ...")
            current_id+=1
            '''print("\t[", end="  ")
            for i in range(len(liste)):
                print(f"V{i+1}: {liste[i]}",end="   ")
            print("]\n")'''
    return "SAT",liste

def fd_checking_allsolution(csp):
    """Summary :    Determine le nombre de solution .

       Arguments
       ---------
       csp : Csp

       Return
       ------
       (tuple)
            (nombre de solution,liste de solution)
    """
    counter = 0
    liste_s = []
    current_id =1
    alpha= None
    domain_list = (csp.nb_var+2)*[None]
    domain_list [1] = copy.deepcopy(csp.domaines)
    liste = []
    while(current_id<=csp.nb_var and current_id>=1):
        counter+=1
        verrou = False
        while not(verrou) and len(domain_list[current_id][current_id])!=0:
            alpha = domain_list[current_id][current_id].pop()
            is_emptyDomain = False
            tmp_domain = copy.deepcopy(domain_list[current_id])
            for k in range(current_id+1,csp.nb_var+1):
                revise_list = revise(csp.contraintes,current_id,alpha,k)
                if revise_list!= None: # non-aucune contrainte?
                    tmp_domain[k]= [ i for i in domain_list[current_id][k] if i in revise(csp.contraintes,current_id,alpha,k)]
                if len(tmp_domain[k])==0:
                    is_emptyDomain = True
                    break
            if not(is_emptyDomain):
                domain_list[current_id+1]=tmp_domain
                verrou = True
        if not(verrou):
            current_id-=1
            if current_id == 0:
                t=len(liste_s)
                if t==0:
                    #print("tour de boucle : ",counter)
                    return (0,[])
                else:
                    return(t,liste_s)
            liste.pop()
        else:
            liste.append(alpha)
            current_id+=1
            if current_id>csp.nb_var:
                #print("tour de boucle : ",counter)
                current_id-=1
                liste_s.append(liste[:])
                liste.pop()
    return -1   #Error

if __name__ == '__main__':
    main()
